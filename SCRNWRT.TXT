       DEF  GETLIN
       REF  LINLST,FMTLST,MGNLST

SCRNWS BSS  >20

* General Concepts:
*
* Character Position - position of a 
*    character within a string
* Display Position - position that a
*    a character should occupy on screen
*    Tabs and indents changes this.
*    Format changes occupy a display
*    position even though they do not
*    occupy a character position.
*
* LINLST - an array of addresses of
*    all the lines in the document.
*    The first entry is a word of 
*    memory containing the total number
*    of lines. Every other entry is a
*    word representing the the address
*    of a string comprising one line.
* FMTLST - an array of data describing
*    the character formats of text in
*    the document. Each entry is four
*    words long. The first word is the
*    index of the line in LINLST. The
*    third byte is the index of the 
*    character in the line. The fourth
*    byte describes bold, italic, 
*    underline, superscript, subscript,
*    and characters per inch.
* MGNLST - an array of data descrbing
*    margins at various points in the
*    document. SCRNWRT only cares about
*    the indent of first line and 
*    hanging indent. All margins are
*    unsigned accept first line indent.
*    Each entry is 6 bytes long. The
*    first word is a line index. The
*    third byte is the left margin. The
*    fourth byte is the right margin.
*    The fifth byte is the top/bottom
*    margin. The sixth byte is the
*    first line indent.
*    The third byte's first bit is
*    set if the paragraph is justified.
*    The fourth byte's first bit is
*    set if the paragraph is centered.

*
* GETLIN
* Get a Line of text to display.
*
* Look at a line in the writer's memory
* and create a version displayable on 
* screen.
*
* Input:
* R0 - line index
* Output:
* R0 - address of created line
* R1 - address of cursor description
* R2 - length of created line
GETLIN DATA SCRNWS,GETLIN+4
       MOV  *R13,R0
* Convert Line Index to string address
       LI   R1,LINLST
	   INCT R1
	   A    R0,R1
	   A    R0,R1
* R1 now points to a location in LINLST
* that contains the string address	   
	   MOV  *R1,R1
* R1 now contains the string address
	   MOVB *R1+,R2
	   SRL  R2,8
	   MOV  R2,R4
* R2 and R4 now contain string length
	   LI   R3,DSPSTR
	   BL   @MGNWRT
       BL   @DOINDT
* Copy the string now
GTLN1  MOVB *R1+,*R3+
	   DEC  R4
	   JNE  GTLN1
* Setup output parameters	   
	   LI   R0,DSPSTR
	   MOV  R0,*R13
	   CLR  @2(13)
	   S    R0,R3
	   MOV  R3,@4(13)
       RTWP

LF     BYTE 10
CR     BYTE 13
SPACE  BYTE >20
* Character code for inverted symbols
INVPL  BYTE >AB
INVMN  BYTE >AD
INV0   BYTE >B0
INV1   BYTE >B1
INV2   BYTE >B2
INV5   BYTE >B5
INV6   BYTE >B6
INV7   BYTE >B7
INVB   BYTE >C2
INVC   BYTE >C3
INVI   BYTE >C9
INVJ   BYTE >CA
INVL   BYTE >CC
INVM   BYTE >CD
INVN   BYTE >CE
INVR   BYTE >D2
INVU   BYTE >D5
INVLB  BYTE >E2
INVLE  BYTE >E5

* If margin settings have changed,
* display notification of changes
MGNWRT LI   R6,MGNLST
       MOV  *R6,R5
MGNW1  AI   R6,6
	   C    *R6,R0
	   JHE  MGNW2
	   DEC  R5
	   JNE  MGNW1
* R5 will look at previous margin entry.
* R6 will look at next margin entry.
MGNW2  MOV  R6,R5
       AI   R5,>FFFA
	   CI   R5,MGNLST
	   JH   MGNW3
	   LI   R5,DFTMGN-2
* Is there a margin entry for the
* current line of text?
MGNW3  C    *R6,R0
	   JEQ  MGNW3A
* No, so store old indent and return
	   AI   R5,5
	   MOVB *R5,R7
	   SRA  R7,8
	   MOV  R7,@INDENT
	   RT
* Yes, look for changes from previous
* margin entry.
MGNW3A INCT R5
       INCT R6
* See if justification changed.
	   MOV  *R5,R7
	   MOV  *R6,R8
	   SZC  @CLRMGN,R7
	   SZC  @CLRMGN,R8
	   C    R7,R8
	   JEQ  MGNW6
* If newly left justified
	   MOV  R8,R8
	   JNE  MGNW4
	   MOVB @INVL,*R3+
	   MOVB @INVJ,*R3+
	   JMP  MGNW6
* If newly justified
MGNW4  CI   R8,>8000
	   JNE  MGNW5
	   MOVB @INVJ,*R3+
	   MOVB @INVU,*R3+
	   JMP  MGNW6
* If newly centered
MGNW5  CI   R8,>0080
	   JNE  MGNW6
	   MOVB @INVC,*R3+
	   MOVB @INVN,*R3+
* See if left margin changed
MGNW6  MOVB *R5+,R7
       MOVB *R6+,R8
	   SZC  @CLRJ,R7
	   SZC  @CLRJ,R8
	   C    R7,R8
	   JEQ  MGNW7
	   MOVB @INVL,*R3+
	   MOVB @INVM,*R3+
* See if right margin changed
MGNW7  MOVB *R5+,R7
       MOVB *R6+,R8
	   SZC  @CLRJ,R7
	   SZC  @CLRJ,R8
	   C    R7,R8
	   JEQ  MGNW8
	   MOVB @INVR,*R3+
	   MOVB @INVM,*R3+
* See if top/bottom margin changed
MGNW8  MOVB *R5+,R7
       MOVB *R6+,R8
	   C    R7,R8
	   JEQ  MGNW9
	   MOVB @INVB,*R3+
	   MOVB @INVM,*R3+
* Store indent
MGNW9  INC  R5
       MOVB *R6+,R8
	   SRA  R8,8
	   MOV  R8,@INDENT
	   RT
	   
* Indent if nessecary
DOINDT 
* Find out if this is the begining of a
* paragraph.
       MOV  R0,R5
* If index is zero, then yes.
       JEQ  DOIND4
       DEC  R5
* Convert Line Index to string address
       LI   R6,LINLST
	   INCT R6
	   A    R5,R6
	   A    R5,R6
* Did previous line end in Carrg Return?
       MOVB *R6,R5
	   SRL  R5,8
* If previous liine is empty, then no.
	   MOV  R5,R5
	   JEQ  DOIND3
	   A    R5,R6
* Check last byte of string.
	   CB   *R6,@CR
	   JEQ  DOIND4
* Check last two bytes of string.
	   CB   *R6,@LF
	   JNE  DOIND3
	   DEC  R6
       CB   *R6,@CR
	   JEQ  DOIND4
* No, not begining of paragraph.
DOIND3 SETO R5
       JMP  DOIND5
* Yes, begining of paragraph.
DOIND4 CLR  R5
DOIND5 MOV  @INDENT,R6
       JLT  DOIND8
* First line indent
* Return if not begining of paragraph
       MOV  R5,R5
	   JNE  DOIND7
* For now, assume 10 CPI
* Return if indent is 0 chars.
DOIN5A SRL  R6,2
	   JEQ  DOIND7
DOIND6 MOVB @SPACE,*R3+
       DEC  R6
	   JNE  DOIND6
DOIND7 RT
* Later line indent
* Return if beginning of paragraph
DOIND8 MOV  R5,R5
       JEQ  DOIND7
       JMP  DOIN5A

DFTMGN DATA >1414,>2800
CLRMGN DATA >7F7F
CLRJ   DATA >80FF
INDENT BSS  >2

DSPSTR BSS  >100
       END