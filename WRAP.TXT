       DEF  WRAP
       REF  LINLST,FMTLST,MGNLST
       REF  BUFALC,BUFCPY,BUFREE
* Workspace
       REF  WRAPSP
* Constants
       REF  SPACE,DASH,LF,CR,BLKUSE
* Variables
*
       REF  CPL
* Index within Line List of line being
* wrapped
       REF  WRPLN
* Same as WRPLN accept that WRPLNR
* stores an address in the line list.
* The word at WRPLNR's address is in
* turn the address of a line.
       REF  WRPLNR
* Address of unified line.
       REF  UNIADR
* Size
       REF  UNIEND
* Last address within the line list that
* points to this same paragraph.
* Therefore, also the last entry that
* can be copied over.
       REF  FINLIN
* Count the number of new lines inserted
       REF  INSCNT

* Maximum width of a 4 inch line
LNWDTH DATA 120*4
* Character Width in n/120-inch
* 10 cpi
CPI10  DATA 12

*
* Wrap
*
* Input:
* R0 - Line index. Wrap from here.
* Output:
* R0 - >FFFF implies an error.
WRAP   DATA WRAPSP,WRAP+4
*
* Get index of starting line.
       MOV  *R13,@WRPLN
*
       CLR  @INSCNT
* Get address in line list
       MOV  *R13,R0
       INC  R0
       SLA  R0,1
       A    @LINLST,R0
       MOV  R0,@WRPLNR
* Find Characters Per Line
       CLR  R2
       MOV  @LNWDTH,R3
       DIV  @CPI10,R2
       MOV  R2,@CPL
* Unify a paragraph
       BL   @UNIPAR
*
       MOV  @UNIADR,R10
*
WRAP2  BL   @FNDBRK
       BL   @DELLIN
       BL   @MAKLIN
       INC  @WRPLN
       INCT @WRPLNR
       A    R2,R10
       C    R10,@UNIEND
       JL   WRAP2
*
       MOV  @UNIADR,R0
       BLWP @BUFREE
       BL   @ADJFMT
       BL   @RMXTRA
*
       RTWP

*
* Unify the remainder of a paragraph
* into one line.
*
UNIPAR
* Let R5 point to the address in the
* line list that represents the line to
* be wrapped.
       MOV  @WRPLN,R5
       INC  R5
       SLA  R5,1
       A    @LINLST,R5
*
       MOV  R5,R6
* Let R0 hold the number of characters
* in the paragraph.
       CLR  R0
*
UNI1   MOV  *R5,R3
* Accumulate the number of characters in
* all of the lines in the paragraph.
       MOVB *R3,R4
       SRL  R4,8
       A    R4,R0
* Check if this is the last line in the
* paragraph.
       A    R3,R4
       CB   *R4,@CR
       JEQ  UNI2
       CB   *R4,@LF
       JEQ  UNI2
*
       INCT R5
       JMP  UNI1
* Allocate space for unified line.
UNI2   MOV  R0,@UNIEND
       BLWP @BUFALC
       CI   R0,>FFFF
       JNE  UNI2B
       B    @WRPERR
*
UNI2B  MOV  R0,@UNIADR
       A    R0,@UNIEND
* Copy the lines to the unified line.
       MOV  R0,R1
UNI3   MOV  *R6,R0
       MOVB *R0,R2
       INC  R0
       SRL  R2,8
       BLWP @BUFCPY
*
       A    R2,R1
*
       INCT R6
       C    R6,R5
       JLE  UNI3
*
       MOV  R5,@FINLIN
       RT

*
* Find Break
*
FNDBRK
* Point R2 to one line's width later
* than position of R10
       MOV  @CPL,R2
       A    R10,R2
* Is R2 past end of paragraph?
       C    R2,@UNIEND
       JHE  FND5
*
       CB   *R2,@SPACE
       JEQ  FND2
* Find last invisible character in early
* line
FND1   DEC  R2
       CB   *R2,@SPACE
       JEQ  FND3
       CB   *R2,@DASH
       JEQ  FND3
       JMP  FND1
* Find first visible character in next
* line
FND2   INC  R2
       CB   *R2,@SPACE
       JEQ  FND2
       JMP  FND4
FND3   INC  R2
* Save break address in R8
FND4   MOV  R2,R8
       RT
* All remaining characters fit on one
* line.
FND5   MOV  @UNIEND,R8
       RT

* 
* Either replace a line from buffer
* with a line just created
* or insert a space in the line list
* 
DELLIN MOV  @WRPLNR,R5
*
       C    R5,@FINLIN
       JH   INSRT
* Delete
       MOV  *R5,R0
       BLWP @BUFREE
       RT
*
* Insert space for a line
*
INSRT  MOV  @LINLST,R4
* Get required byte-size of current line
* list plus one new element
       MOV  *R4,R2
       INCT R2
       SLA  R2,1
* Get space of line lists current memory
* chunk
       MOV  R4,R0
       DECT R0
       MOV  *R0,R0
       SZC  @BLKUSE,R0
       DECT R0
* Does line list's memory block have
* enough space?
       C    R2,R0
       JLE  INSRT2
* No, create another buffer roughly
* twice the size of the old one.
       SLA  R0,1
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  WRPERR
* Copy line list
       MOV  *R4,R2
       INC  R2
       SLA  R2,1
       MOV  R0,R1
       MOV  R4,R0
       BLWP @BUFCPY
* Delete old line list
       BLWP @BUFREE
* Save address of new line list
       MOV  R1,@LINLST
       MOV  R1,R4
* Find new address of the address of the
* wrap line
       MOV  @WRPLN,R5
       INC  R5
       SLA  R5,1
       A    @LINLST,R5
       MOV  R5,@WRPLNR
* Insert a space in line list
INSRT2 
* Find end of the list
       MOV  *R4,R2
       SLA  R2,1
       A    R4,R2
       MOV  R2,R1
       INCT R1
* Copy contents one word later in memory
INSRT3 MOV  *R2,*R1
       DECT R2
       DECT R1
       C    R2,R5
       JHE  INSRT3
* Increase size of new line list by one
       INC  *R4
* Record the fact that we inserted a
* line.
       INC  @INSCNT
       RT

*
* Make a line
*
MAKLIN MOV  R8,R2
       S    R10,R2
*
       MOV  R2,R0
       INC  R0
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  WRPERR
*
       MOV  R2,R1
       SLA  R1,8
       MOVB R1,*R0+
*
       MOV  R0,R1
       MOV  R10,R0
       BLWP @BUFCPY
* Save the line in line list.
       DEC  R1
       MOV  R1,*R5
       RT

WRPERR MOV  R0,*R13
       RTWP

*
* Adjust Format Lines
*
ADJFMT
* Check if lines were inserted.
       MOV  @INSCNT,R0
       JNE  AJFMT3
* Check if lines were deleted
       MOV  @FINLIN,R0
       INCT R0
       MOV  @WRPLNR,R1
       S    R1,R0
       JGT  AJFMT2
       RT
* Wrap algorithm cause formats to move
* up.
AJFMT2 SRL  R0,1
       NEG  R0
* Wrap algorithm caused formats to move
* down.
AJFMT3 MOV  @WRPLN,R1
       MOV  @FMTLST,R2
       MOV  *R2,R3
       SLA  R3,2
       A    R2,R3
* R2 Is the location of the format entry.
* R3 already contains the location of the
*    last format entry.
* Increase R2 by 4
AJFMT4 C    *R2+,*R2+
       C    *R2,R1
       JL   AJFMT5
       A    R0,*R2
AJFMT5 C    R2,R3
       JL   AJFMT4
       RT

* 
* Remove extra lines when text wrapped
* up. For example, the wrapping changed
* the paragraph from being 7 lines long
* to only 5 lines long. We recorded over
* 5 entries in the line list earlier,
* and now we need to delete 2 entries.
* 
RMXTRA MOV  @LINLST,R4
* Set R0 to the address withing the line
* list that holds the address of the
* first line in the next paragraph.
       MOV  @FINLIN,R0
       INCT R0
* Set R1 to the address in the line list
* following an address that we wrapped
* into. If we need to remove anything
* from the line list, this will be the
* first line that needs to be removed.
       MOV  @WRPLNR,R1
* If R0 points to the same location as
* R1, then there is nothing to delete.
       C    R0,R1
       JLE  XTRA2
* Find the space in the line list
* following the address in R0.
XTRA1  MOV  *R4,R2
       INCT R2
       SLA  R2,1
       A    R4,R2
       S    R0,R2
*
       BLWP @BUFCPY
* Decrease size of line list
       S    R1,R0
       SRL  R0,1
       S    R0,*R4
XTRA2  RT
       END