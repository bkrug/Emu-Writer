       DEF  ARYALC,ARYADD,ARYINS,ARYDEL
       DEF  ARYADR
*
       REF  BUFALC,BUFREE,BUFCPY
       REF  ARRYWS,BLKUSE

* TODO: ARYDEL should be able to shrink
* the array size if it is half empty

*
* Allocate space for an array.
* Initially there will be space for
* 8 items.
*
* Input:
* R0 - Size of each item
*      (1 for 2 bytes,
*       2 for 4 bytes,
*       3 for 8 bytes, etc.)
* Output:
* R0 - address of array
*      >FFFF indicates error
ARYALC DATA ARRYWS,ARYALC+4
* Input of zero is invalid
       MOV  *R13,R0
       MOV  *R13,R3
       JEQ  ALC2
* Get array item size
       LI   R2,1
       SLA  R2,0
* We'll initially give array space for
* 3 items and the array header
       SLA  R2,2
* Allocate space
       MOV  R2,R0
       BLWP @BUFALC
* Handle memory error
       CI   R0,>FFFF
       JEQ  ALC2
* Declare that the array length is 0
       CLR  *R0
* If the item size is something other
* than 2, record size in bytes 2 and 3.
       CI   R3,1
       JEQ  ALC1
       SOC  @BLKUSE,*R0
       MOV  R0,R1
       INCT R1
       MOV  R3,*R1
* Notify caller of array address
ALC1   MOV  R0,*R13
       RTWP
* Notify caller of error
ALC2   SETO *R13
       RTWP


*
* Add element to end of array.
*
* Input:
* R0 - array address
* Output:
* R0 - address of array
*      >FFFF indicates error
* R1 - address of new item
ARYADD DATA ARRYWS,ARYADD+4
*
       BL   @ADRSIZ
       BL   @REALC
* Put address of soon-to-be last element
* in the array in caller's R1
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R7,@2(13)
* Increase length of array
       INC  *R10
* Put array address in caller's R0
ADDRT  MOV  R10,*R13
       RTWP


*
* Insert element into the array.
*
* Input:
* R0 - array address
* R1 - index to insert at
* Output:
* R0 - address of array
*      >FFFF indicates error
* R1 - address of new item
ARYINS DATA ARRYWS,ARYINS+4
       BL   @ADRSIZ
       BL   @REALC
       B    @CPYBCK
*
* Put address of new element in the
* array in caller's R1
*
INS1   MOV  R1,@2(13)
*
* Increase length of array
*
       INC  *R10
*
* Put array address in caller's R0
*
INSRT  MOV  R10,*R13
       RTWP


*
* Remove element from the array.
*
* Input:
* R0 - array address
* R1 - index to delete at
* Output:
* R0 - address of array
*      >FFFF indicates error
ARYDEL DATA ARRYWS,ARYDEL+4
*
       BL   @ADRSIZ
* Get address directly after array.
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R7,R2
* Get destination to copy to.
       MOV  @2(13),R8
       BL   @ADDRES
       MOV  R7,R1
* Get source to copy from.
       MOV  R9,R0
       LI   R3,1
       SLA  R3,0
       MOV  R7,R0
       A    R3,R0
* Get length to copy
       S    R0,R2
*
       BLWP @BUFCPY
* Decrease array length
       DEC  *R10
       RTWP


*
* Get index address
*
* Input:
* R0 - array address
* R1 - index of item
* Output:
* R1 - address of item
ARYADR DATA ARRYWS,ARYADR+4
       MOV  *R13,R10
       MOV  @2(13),R8
       BL   @ADRSIZ
       BL   @ADDRES
       MOV  R7,@2(13)
       RTWP

*
* Get address of array and exponent of
* size of each item.
*
* Output:
*  R0 - exponent for item size
*  R9 - exponent for item size
*  R10 - address of array
ADRSIZ
* First get address of array
       MOV  *R13,R10
* Get memory size of array item
       COC  @BLKUSE,R1
       JEQ  ADD1
* Item size is 2^1
       LI   R0,1
       JMP  ADD2
* Get item size from byte 2 & 3
ADD1   SZC  @BLKUSE,R2
       MOV  R10,R9
       INCT R9
       MOV  *R9,R0
* Continue to store item size in R9
ADD2   MOV  R0,R9
       RT

*
* Get Address of index in R8
*
* Input:
*  R8 - index of item
*  R9 - exponent for item size
*  R10 - address of array
* Output:
*  R7 - item address
ADDRES MOV  R8,R7
       MOV  R9,R0
       INC  R7
       SLA  R7,0
       A    R10,R7
       RT

*
* Check if it is necessary to move the
* array to an area of a larger size.
*
* Input:
*  R0 - exponent for item size
*  R9 - exponent for item size
*  R10 - address of array
* Output:
*  R0, R1, R2, R3
REALC
*
* Get potential size of array after add.
* Put in R2
* Calc: (array length + 2) * Item size
*
       MOV  *R10,R2
       INCT R2
       SLA  R2,0
*
* Get current size of memory block - 2
* Put in R3
*
       MOV  R10,R3
       DECT R3
       MOV  *R3,R3
       SZC  @BLKUSE,R3
       DECT R3
*
* Increase memory reserved for array if
* necessary.
*
       C    R2,R3
       JLE  REALC2
* Allocate space
       MOV  R2,R0
       BLWP @BUFALC
       CI   R0,>FFFF
       JNE  REALC1
       SETO *R13
       RTWP
* Copy to new location
REALC1 MOV  R0,R1
       MOV  R10,R0
       BLWP @BUFCPY
* Free up old space
       BLWP @BUFREE
* Save new address
       MOV  R1,R10
REALC2 RT

*
* Copy part of memory backwards
*
* Input:
*  R9 - exponent for item size
*  R10 - address of array
*  R13 - caller's workspace
* Output:
*  R0,R1,R2,R3,R4,R7,R8
CPYBCK
* Get insertion index
       MOV  @2(13),R8
* Get address of insertion index
       BL   @ADDRES
       MOV  R7,R1
* Get address immediately following the
* end of the array.
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R7,R3
* Get address of last item in array
       MOV  R9,R0
       LI   R4,1
       SLA  R4,0
       MOV  R3,R2
       S    R4,R2
* Copy each word until we reach the
* address of insertion.
CPYBK1 MOV  *R2,*R3
       DECT R2
       DECT R3
       C    R2,R1
       JHE  CPYBK1
*
       B    @INS1

       END