       DEF  ARYALC,ARYADD,ARYINS,ARYDEL
       DEF  ARYADR
*
       REF  BUFALC,BUFREE,BUFCPY
       REF  ARRYWS,BLKUSE

* TODO: ARYDEL should be able to shrink
* the array size if it is half empty

*
* Allocate space for an array.
* Initially there will be space for
* 8 items.
*
* Input:
* R0 - Size of each item
*      (1 for 2 bytes,
*       2 for 4 bytes,
*       3 for 8 bytes, etc.)
* Output:
* R0 - address of array
*      >FFFF indicates error
ARYALC DATA ARRYWS,ARYALC+4
* Input of zero is invalid
       MOV  *R13,R0
       MOV  *R13,R3
       JEQ  ALC2
* Get array item size * 4 + 4.
* We'll initially give array space for
* 4 items and the array header
       LI   R2,4
       SLA  R2,0
       C    *R2+,*R2+           Add four to R2
* Allocate space
       MOV  R2,R0
       BLWP @BUFALC
* Handle memory error
       CI   R0,>FFFF
       JEQ  ALC2
* Notify caller of array address
       MOV  R0,*R13
* Declare that the array length is 0
       CLR  *R0+
* Put record item size in bytes 2 and 3.
       MOV  R3,*R0
       RTWP
* Notify caller of error
ALC2   SETO *R13
       RTWP


*
* Add element to end of array.
*
* Input:
* R0 - array address
* Output:
* R0 - address of array
*      >FFFF indicates error
* R1 - address of new item
ARYADD DATA ARRYWS,ARYADD+4
*
       BL   @ADRSIZ
       BL   @REALC
* Put address of soon-to-be last element
* in the array in caller's R1
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R8,@2(13)
* Increase length of array
       INC  *R10
* Put array address in caller's R0
ADDRT  MOV  R10,*R13
       RTWP


*
* Insert element into the array.
*
* Input:
* R0 - array address
* R1 - index to insert at
* Output:
* R0 - address of array
*      >FFFF indicates error
* R1 - address of new item
ARYINS DATA ARRYWS,ARYINS+4
       BL   @ADRSIZ
       BL   @REALC
       B    @CPYBCK
*
* Put address of new element in the
* array in caller's R1
*
INS1   MOV  R1,@2(13)
*
* Increase length of array
*
       INC  *R10
*
* Put array address in caller's R0
*
       MOV  R10,*R13
       RTWP


*
* Remove element from the array.
*
* Input:
* R0 - array address
* R1 - index to delete at
* Output:
* R0 - address of array
*      >FFFF indicates error
ARYDEL DATA ARRYWS,ARYDEL+4
*
       BL   @ADRSIZ
* Get address directly after array.
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R8,R2
* Get destination to copy to.
       MOV  @2(13),R8
       BL   @ADDRES
       MOV  R8,R1
* Get source to copy from.
       MOV  @2(13),R8
	   DEC  R8
       BL   @ADDRES
       MOV  R8,R0
* Get length to copy
       S    R0,R2
*
       BLWP @BUFCPY
* Decrease array length
       DEC  *R10
       RTWP


*
* Get index address
*
* Input:
* R0 - array address
* R1 - index of item
* Output:
* R1 - address of item
ARYADR DATA ARRYWS,ARYADR+4
       BL   @ADRSIZ
       MOV  @2(13),R8
       BL   @ADDRES
       MOV  R8,@2(13)
       RTWP

*
* Get address of array and exponent of
* size of each item.
*
* Output:
*  R0 - exponent for item size
*  R2 - (changed)
*  R10 - address of array
ADRSIZ
* First get address of array
       MOV  *R13,R10
* Get memory size of array item
       MOV  R10,R9
       INCT R9
       MOV  *R9,R0
       RT

*
* Get Address of index in R8
*
* Input:
*  R0 - exponent for item size
*  R8 - index of item
*  R10 - address of array
* Output:
*  R8 - item address
ADDRES SLA  R8,0
       A    R10,R8
       C    *R8+,*R8+
       RT

*
* Check if it is necessary to move the
* array to an area of a larger size.
*
* Input:
*  R0 - exponent for item size
*  R10 - address of array
* Output:
*  R0, R1, R2, R3
*  R9 - exponent for item size
REALC
* Continue to store item size in R9
       MOV  R0,R9
*
* Get potential size of array after add.
* Put in R2
* Calc: (array length + 1) * Item size + 4
*
       MOV  *R10,R2
       INC  R2
       SLA  R2,0
       C    *R2+,*R2+
*
* Get current size of memory block - 2
* Put in R3
*
       MOV  R10,R3
       DECT R3
       MOV  *R3,R3
       SZC  @BLKUSE,R3
       DECT R3
*
* Increase memory reserved for array if
* necessary.
*
       C    R2,R3
       JLE  REALC2
* Allocate required space * 2
       MOV  R2,R0
       SLA  R0,1
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  RTERR
* Copy to new location
       MOV  R0,R1
       MOV  R10,R0
       BLWP @BUFCPY
* Free up old space
       BLWP @BUFREE
* Save new address
       MOV  R1,R10
REALC2 RT

RTERR  SETO *R13
       RTWP


*
* Copy part of memory backwards
*
* Input:
*  R9 - exponent for item size
*  R10 - address of array
*  R13 - caller's workspace
* Output:
*  R0
*  R1 - Address of insertion index
*  R2,R3,R4,R7,R8
CPYBCK
* R0 must have memory size of item
       MOV  R9,R0
* Get address of insertion index
       MOV  @2(13),R8
       BL   @ADDRES
       MOV  R8,R1
* Get address immediately following the
* end of the array.
       MOV  *R10,R8
       BL   @ADDRES
       MOV  R8,R3
* Get address of last item in array
       MOV  R9,R0
       LI   R4,1
       SLA  R4,0
       MOV  R3,R2
       S    R4,R2
* Copy each word until we reach the
* address of insertion.
CPYBK1 MOV  *R2,*R3
       DECT R2
       DECT R3
       C    R2,R1
       JHE  CPYBK1
*
       B    @INS1

       END