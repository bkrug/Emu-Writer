       DEF  DISP
* Mocked methods
       REF  VDPADR,VDPWRT
*
       REF  DISPWS
       REF  LINLST,FMTLST,MGNLST
       REF  PARINX
       REF  WINOFF,WINPAR,WINLIN
       REF  STSTYP,STSENT,STSPAR,STSWIN
       REF  ERRMEM

SPACE  TEXT '                                        '
SCRNWD EQU  40
FORTY  DATA 40

       TEXT 'DISP'
DISP   DATA DISPWS,DISP+4

*
* Calculate the number of rows at the
* top of the screen that don't need to
* be rewritten. Put the result in R2.
*
* If cursor's paragraph is at top of
* screen, then set VDP address to the
* first document row.
       CLR  R2
       C    @WINPAR,@PARINX
	   JEQ  DISP3
*
       MOV  @WINPAR,R1
* Let R2 total screen rows to skip
       MOV  @WINLIN,R2
       NEG  R2
* Let R3 = paragraph address
DISP2  MOV  R1,R3
       BL   @PARADR
* Let R3 = wrap list address
       INCT R3
       MOV  *R3,R3
* Add paragraph length to row count
       A    *R3,R2
       INC  R2
* Keep going until we reach the
* cursor's paragraph
       INC  R1
       C    R1,@PARINX
       JL   DISP2
* Skip two rows that are reserved for
* document information.
DISP3  INCT R2
       MOV  R2,R10
       
*
* Set VDP write address so that the
* routine can redraw the current
* paragraph.
*
* Let R0 = R2 * screen width
       MPY  @FORTY,R2
       MOV  R3,R0
* Set VDP write address
       BL   @VDPADR
       
*
* Redraw the rows for one paragraph of
* text.
*
* Let R2 = starting paragraph-line
       CLR  R2
       C    @WINPAR,@PARINX
	   JNE  DISP4
       MOV  @WINLIN,R2
* Let R3 = address of cursor's paragraph
DISP4  MOV  @PARINX,R3
       BL   @PARADR
* Let R3 = address of paragraph text
* Let R4 = length of paragraph
* Let R5 = address two bytes prior to
*          wrap list's first element
* Let R6 = length of wrap list
       MOV  *R3+,R4
       MOV  *R3+,R5
       MOV  *R5+,R6
* If paragraph has only one line, use
* different algorithm.
       JEQ  DISP10
* Check if displaying starts with the
* first line of the paragraph.
       MOV  R2,R0
	   JNE  DISP4B
* Write first line of paragraph
	   BL   @WRTFST
	   JMP  DISP6
* Starting in the middle of the
* paragraph. Adjust R5 and R6.
DISP4B S    R2,R6
	   A    R2,R5
	   A    R2,R5
* Write a row of text
DISP5  BL   @WRTMID
* Track screen-row
DISP6  INC  R10
	   CI   R10,24
	   JHE  DISP9
* Check if this is last paragraph-line
       DEC  R6
       JH   DISP5
* Write the last line
       BL   @WRTLST
* Track screen-row
DISP8  INC  R10
*
DISP9  RTWP

* Write one-line paragraph.
DISP10 BL   @WRTONE
	   JMP  DISP8

*
* Get paragraph address from index
*
* Input:
* R3 - paragraph index
* Output:
* R3 - paragraph address
PARADR SLA  R3,1
       A    @LINLST,R3
       C    *R3+,*R3+
       MOV  *R3,R3
       RT

*
* WRTFST
* Write first line within a paragraph
*
* Input:
* R3,R4,R5
WRTFST MOV  R11,R12
* Write text
       BL   @PFSTLN
       MOV  R1,R7
       BL   @VDPWRT
* Write trailing spaces
       MOV  R7,R1
       BL   @PWHITE
	   BL   @VDPWRT
*
	   B    *R12

*
* WRTMID
* Write one line within a paragraph
*
* Input:
* R3,R4,R5
WRTMID MOV  R11,R12
* Write text
       BL   @PMIDLN
       MOV  R1,R7
       BL   @VDPWRT
* Write trailing spaces
       MOV  R7,R1
       BL   @PWHITE
	   BL   @VDPWRT
*
	   B    *R12

*
* WRTLST
* Write last line within a paragraph
*
* Input:
* R3,R4,R5
WRTLST MOV  R11,R12
* Write text
       BL   @PLSTLN
       MOV  R1,R7
       BL   @VDPWRT
* Write trailing spaces
       MOV  R7,R1
	   BL   @PWHITE
       BL   @VDPWRT
*
       B    *R12
	   
*
* WRTONE
* Write a one line paragraph
*
* Input:
* R3,R4,R5
WRTONE MOV  R11,R12
* Write text
       BL   @PONELN

*
* WRTLIN
*
* Write one line of text onto screen.
*
* R0 already contains the address of
* visible text
* R1 already contains the length
WRTLIN
       MOV  R1,R7
       BL   @VDPWRT
* Write trailing spaces
       MOV  R7,R1
	   BL   @PWHITE
       BL   @VDPWRT
*
       B    *R12

*
* PFSTLN
* Set parameters for writing a first
* line of a multiline paragraph
*
* Input: 
*  R3 - paragraph text address
*  R5 - wrap list element address
* Output:
* R0, R1, R5
PFSTLN CLR  R0
       JMP  PMLN0	  
	  
*
* PMIDLN
* Set parameters for writing a
* non-first and non-last line of
* a multiline paragraph
*
* Input: 
*  R3 - paragraph text address
*  R5 - wrap list element address
* Output:
* R0, R1, R5
PMIDLN MOV  *R5,R0
       CLR  R1
       S    *R5,R1
PMLN0  INCT R5
       A    R3,R0
	   A    @WINOFF,R0
	   A    *R5,R1
	   S    @WINOFF,R1
	   JGT  PMLN1
	   CLR  R1
PMLN1  CI   R1,SCRNWD
       JLE  PMLN2
	   LI   R1,SCRNWD
PMLN2
       RT

*
* PLSTLN
* Set parameters for writing a last
* line of a mulitline paragraph
*
* Input: 
*  R3 - paragraph text address
*  R4 - length or paragraph
*  R5 - wrap list element address
* Output:
* R0, R1, R5
*
* Let R1 be the length of last line 
* minus window offset, but between 0
* and 40
PLSTLN MOV  R4,R1
       S    *R5,R1
	   S    @WINOFF,R1
	   JGT  PLLN1
	   CLR  R1
PLLN1  CI   R1,SCRNWD
	   JLE  PLLN2
       LI   R1,SCRNWD
*
PLLN2  MOV  *R5,R0
       A    R3,R0
	   A    @WINOFF,R0
	   RT
	   
*
* PONELN
* Set parameters for writing a one line
* paragraph
*
* Input:
*  R3 - paragraph text address
*  R4 - length or paragraph
* Output:
* R0, R1
PONELN MOV  R3,R0
       A    @WINOFF,R0
* Let R1 be the length of paragraph 
* minus window offset, but between
* 0 and 40
       MOV  R4,R1
       S    @WINOFF,R1
	   JGT  POLN1
	   CLR  R1
POLN1  CI   R1,SCRNWD
	   JLE  POLN2
	   LI   R1,SCRNWD
POLN2
       RT

*
* Set parameters for writing whitespace
*
* Input:
* R1 - characters already written to
*      the current row.
* Output:
* R0, R1
PWHITE NEG  R1
       AI   R1,SCRNWD
       LI   R0,SPACE
       RT

       END