       DEF  DISP
* Mocked methods
       REF  VDPADR,VDPWRT
*
       REF  DISPWS
       REF  LINLST,FMTLST,MGNLST
       REF  PARINX
       REF  WINOFF,WINPAR,WINLIN
       REF  STSTYP,STSENT,STSPAR,STSWIN
       REF  ERRMEM

SPACE  TEXT '                                        '
SCRNWD EQU  40
FORTY  DATA 40

       TEXT 'DISP'
DISP   DATA DISPWS,DISP+4

*
* Calculate the number of rows at the
* top of the screen that don't need to
* be rewritten. Put the result in R2.
*
* If cursor's paragraph is at top of
* screen, then set VDP address to the
* first document row.
       CLR  R2
       C    @WINPAR,@PARINX
	   JEQ  DISP3
*
       MOV  @WINPAR,R1
* Let R2 total screen rows to skip
       MOV  @WINLIN,R2
       NEG  R2
* Let R3 = paragraph address
DISP2  MOV  R1,R3
       BL   @PARADR
* Let R3 = wrap list address
       INCT R3
       MOV  *R3,R3
* Add paragraph length to row count
       A    *R3,R2
       INC  R2
* Keep going until we reach the
* cursor's paragraph
       INC  R1
       C    R1,@PARINX
       JL   DISP2
* Skip two rows that are reserved for
* document information.
DISP3  INCT R2
       MOV  R2,R10
       
*
* Set VDP write address so that the
* routine can redraw the current
* paragraph.
*
* Let R0 = R2 * screen width
       MPY  @FORTY,R2
       MOV  R3,R0
* Set VDP write address
       BL   @VDPADR
       
*
* Redraw the rows for one paragraph of
* text.
*
* Let R2 = starting paragraph-line
       CLR  R2
       C    @WINPAR,@PARINX
	   JNE  DISP4
       MOV  @WINLIN,R2
* Let R3 = address of cursor's paragraph
DISP4  MOV  @PARINX,R3
       BL   @PARADR
* Let R3 = address of paragraph text
* Let R4 = length of paragraph
* Let R5 = address two bytes prior to
*          wrap list's first element
* Let R6 = length of wrap list
       MOV  *R3+,R4
       MOV  *R3+,R5
       MOV  *R5+,R6
* If paragraph has only one line, use
* different algorithm.
       JEQ  DISP10
* If starting with first paragraph-line,
* ignore wrap list for one cycle.
       MOV  R2,R0
	   JEQ  DISP6
* Adjust R5 and R6 based on the 
* starting paragraph-line.
       S    R2,R6
	   A    R2,R5
	   A    R2,R5
* Write a row of text
DISP5  MOV  *R5,R0
       CLR  R1
       S    *R5,R1
DISP6  INCT R5
       A    R3,R0
	   A    @WINOFF,R0
	   A    *R5,R1
	   S    @WINOFF,R1
	   JGT  DISP6A
	   CLR  R1
DISP6A CI   R1,SCRNWD
       JLE  DISP6B
	   LI   R1,SCRNWD
DISP6B MOV  R1,R7
       BL   @VDPWRT
* Write trailing spaces
       MOV  R7,R1
       BL   @PWHITE
	   BL   @VDPWRT
* Track screen-row
DISP6C INC  R10
	   CI   R10,24
	   JHE  DISP9
* Check if this is last paragraph-line
       DEC  R6
       JH   DISP5
* Let R4 be the lesser of these:
* - length of last line minus window offset* - screen width
       S    *R5,R4
	   S    @WINOFF,R4
	   JGT  DISP6D
	   CLR  R4
DISP6D CI   R4,SCRNWD
	   JLE  DISP7
       LI   R4,SCRNWD
* Write last row's text.
DISP7  MOV  *R5,R0
       A    R3,R0
	   A    @WINOFF,R0
       MOV  R4,R1
       BL   @VDPWRT
* Track screen-row
DISP8  INC  R10
* Write trailing spaces
       MOV  R4,R1
	   BL   @PWHITE
       BL   @VDPWRT
*
DISP9  RTWP

* Write one-line paragraph.
DISP10 MOV  R3,R0
       A    @WINOFF,R0
* Let R4 be the length of paragraph 
* minus window offset, but between
* 0 and 40
       S    @WINOFF,R4
	   JGT  DISP11
	   CLR  R4
DISP11 CI   R4,SCRNWD
	   JLE  DISP12
	   LI   R4,SCRNWD
* Write line
DISP12 MOV  R4,R1
       BL   @VDPWRT
* Track screen-row and write trailing
* spaces.
	   JMP  DISP8

*
* Get paragraph address from index
*
* Input:
* R3 - paragraph index
* Output:
* R3 - paragraph address
PARADR SLA  R3,1
       A    @LINLST,R3
       C    *R3+,*R3+
       MOV  *R3,R3
       RT
	   
*
* Set parameters for writing whitespace
*
* Input:
* R1 - characters already written to
*      the current row.
* Output:
* R0, R1
PWHITE NEG  R1
       AI   R1,SCRNWD
       LI   R0,SPACE
       RT

       END