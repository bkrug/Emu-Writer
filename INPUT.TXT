       DEF  INPUT
*
       REF  LINLST,FMTLST,MGNLST
       REF  ARYALC,ARYADD,ARYINS,ARYDEL
       REF  ARYADR
       REF  BUFALC,BUFREE,BUFCPY
       REF  WRAP

* variables just for INPUT
       REF  INPTWS
       REF  KEYSTB,KEYSTE,KEYSTX
       REF  OLDSTB,OLDSTE,OLDSTX
       REF  PARINX,LININX,CHRPAX,CHRLIX
       REF  WINOFF
       REF  INSTMD

* constants
       REF  BLKUSE,USRISR,SIX
       REF  INSKEY,ENDINP

INPUT  DATA INPTWS,INPUT+4
       BL   @RSVKS
INPUT0 LIMI 2
       LIMI 0
       C    @KEYSTB,@KEYSTE
       JEQ  INPUT0
* Deallocate the old key buffer and
* allocate a ne key buffer.
       MOV  @KEYSTB,@OLDSTB
       MOV  @KEYSTE,@OLDSTE
       MOV  @KEYSTX,@OLDSTX
       BL   @RSVKS
* Record space to deallocate later.
       MOV  @OLDSTB,R12
* Process the new keystrokes
INPUT1 MOV  @OLDSTB,R10
*
       CB   *R10,@INSKEY
       JEQ  INSSWP
* Check if this was the end of a
* unit test.
       CB   *R10,@ENDINP
       JEQ  INPTRT
* Handle visible character key strokes
       B    @ADDTXT
* Are there more keystrokes to process?
INPUT2 LIMI 2
       LIMI 0
       INC  @OLDSTB
       C    @OLDSTB,@OLDSTE
       JL   INPUT1
* Wrap line
       MOV  @PARINX,R0
       BLWP @WRAP
* Free up old space
       MOV  R12,R0
       BLWP @BUFREE
       JMP  INPUT0

INPTRT RTWP

INSSWP INV  @INSTMD
       JMP  INPUT2

* Reserve new key stream
RSVKS
       LI   R0,32
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  RTERR
       MOV  R0,@KEYSTB
       MOV  R0,@KEYSTE
       AI   R0,32
       MOV  R0,@KEYSTX
       RT

* Somehow let the user know that there
* is no remaining buffer space.
RTERR  RTWP

* User typed some text.
* Put it in the buffer.
* R10 hold address of next input key
ADDTXT
* Get paragraph address
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
* Decide if to insert or overwrite.
       MOV  @INSTMD,R2
       JNE  OVRWRT
* Check if there is space to insert a
* new character.
* Let R1 be the address in paragraph
* list of current paragraph.
* Let R3 be the address of the
* paragraph.
* Let R5 be the amount of new space
* required.
* Let R6 be the address in the
* paragraph list.
       MOV  R1,R6
       MOV  *R6,R3
       MOV  R3,R4
       DECT R4
       MOV  *R4,R4
       SZC  @BLKUSE,R4
       DECT R4
       MOV  *R3,R5
       AI   R5,5
       C    R5,R4
       JLE  ADDTX1
* Allocate more space
       AI   R5,15
       MOV  R5,R0
       BLWP @BUFALC
       MOV  R0,R1
       MOV  R3,R0
       MOV  R5,R2
       AI   R2,-16
       BLWP @BUFCPY
       MOV  R1,R3
       BLWP @BUFREE
       MOV  R3,*R6
* Insert character.
* Let R4 contain address following
* the paragraph
* Increase paragraph length by one.
* Change R3 to insertion address.
ADDTX1
       MOV  *R3,R4
       INC  *R3
       C    *R3+,*R3+
       A    R3,R4
       A    @CHRPAX,R3
* Copy
       MOV  R4,R5
       DEC  R5
ADDCPY MOVB *R5,*R4
       DEC  R4
       DEC  R5
       LIMI 2
       LIMI 0
       C    R5,R3
       JHE  ADDCPY
* put keystroke in new space
RPLTXT MOVB *R10,*R3
* Increase character indexes.
       INC  @CHRPAX
       INC  @CHRLIX
* Set window offset
       LI   R1,20
OFFST1 MOV  @CHRLIX,R2
       S    @WINOFF,R2
       CI   R2,40
       JL   OFFST2
       A    R1,@WINOFF
       JMP  OFFST1
OFFST2
*
       B    @INPUT2

* Overwrite text
* R1 already contains address in
* paragraph list
* Give R3 address within paragraph
* to write text to.
OVRWRT MOV  *R1,R3
       C    *R3+,*R3+
       A    @CHRPAX,R3
       JMP  RPLTXT

       END