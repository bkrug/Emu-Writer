       DEF  INPUT
*
       REF  LINLST,FMTLST,MGNLST
       REF  ARYALC,ARYADD,ARYINS,ARYDEL
       REF  ARYADR
       REF  BUFALC,BUFREE,BUFCPY

* variables just for INPUT
       REF  INPTWS
       REF  PARINX,CHRPAX
       REF  INSTMD,INPTMD
       REF  KEYSTR,KEYEND,KEYWRT,KEYRD

* constants
       REF  BLKUSE,USRISR,SIX
       REF  ENDINP
       REF  CHRMIN,CHRMAX
       REF  STSTYP,STSENT,STSPAR,STSWIN

* Unspecified input mode
MODENN EQU  0
INPTNN DATA 0
* Text input mode
MODEXT EQU  1
INPTXT DATA 1
* Movement input mode
MODEMV DATA 2
INPTMV DATA 2

*
* Process the new keystrokes
*
INPUT  DATA INPTWS,INPUT+4
* Reset the input mode to unspecified
       CLR  @INPTMD
	   JMP  INPTBG
* Reset Document-Status bits
       SZC  @STSTYP,*R13
	   SZC  @STSENT,*R13
*
INPUT1 MOV  @KEYRD,R10
* Handle visible character key strokes
       CB   *R10,@CHRMIN
       JL   KEYBRC
       CB   *R10,@CHRMAX
       JH   KEYBRC
       B    @ADDTXT
* Branch to non-typing routine specified
* by key code in R10
KEYBRC LI   R0,ROUTKY
       MOV  R0,R2
KYBRC2 CB   *R10,*R0+
       JEQ  KYBRC3
       CI   R0,ROUTKE
       JL   KYBRC2
       JMP  KYBRC4
KYBRC3 DEC  R0
       S    R2,R0
* R0 now has index of routine
* Let R1 = address of desired routine
       LI   R1,ROUTIN
       SLA  R0,1
       A    R0,R1
       MOV  *R1,R1
* Let R3 = acceptable input mode
       LI   R3,EXPMOD
	   A    R0,R3
* Set Input mode if currently unset
       C    @INPTMD,@INPTNN
	   JNE  KYBRC5
	   MOV  *R3,@INPTMD
* If the next key is for different
* input mode, leave routine
KYBRC5 C    *R3,@INPTMD
	   JNE   INPTRT
* Branch to routine associated with key
       B    *R1
KYBRC4
* If we got here, this keystroke is 
* unrecognized. Skip it.
INPUT3 BL   @INCKRD
* Are there more keystrokes to process?
INPTBG C    @KEYRD,@KEYWRT
       JNE  INPUT1
* No, there are not.
INPTRT RTWP

INSKEY EQU  >04
BCKKEY EQU  >08
FWDKEY EQU  >09
UPPKEY EQU  >0B
DWNKEY EQU  >0A
ENTER  EQU  >0D

ROUTKY BYTE INSKEY,BCKKEY,FWDKEY,ENTER
ROUTKE
       EVEN
ROUTIN DATA INSSWP,BACKSP,FWRDSP,ISENTR
EXPMOD DATA MODEXT,MODEMV,MODEMV,MODEXT

* Move position in key stream forwards
* by one address.
INCKRD MOV  @KEYRD,R0
       INC  R0
       CI   R0,KEYEND
       JL   UPDBUF
       LI   R0,KEYSTR
UPDBUF MOV  R0,@KEYRD
       RT

* Toggle insert/overwrite mode.
INSSWP INV  @INSTMD
       JMP  INPUT3

*
* Backspace by one position
*
BACKSP DEC  @CHRPAX
       JLT  BACKS1
       JMP  BACKRT
* Backspace to the end of previous
* paragraph.
BACKS1 DEC  @PARINX
       JLT  BACKS2
* Find the length of the paragraph and
* use that as the new character-within-
* paragraph-index.
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
       MOV  *R1,R1
       MOV  *R1,@CHRPAX
       JMP  BACKRT
* The cursor must already be at the
* beginning of the document.
BACKS2 CLR  @CHRPAX
       CLR  @PARINX
BACKRT B    @INPUT3

*
* Fordward space by one position
*
FWRDSP INC  @CHRPAX
* See if we moved beyong paragraph end.
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
       MOV  *R1,R1
       C    @CHRPAX,*R1
       JH   FWRDS1
       JMP  FWRDRT
* Move to next paragraph.
FWRDS1 INC  @PARINX
       C    @PARINX,*R0
       JEQ  FWRDS2
       CLR  @CHRPAX
       JMP  FWRDRT
* Apparently we reached end of document.
FWRDS2 DEC  @PARINX
       DEC  @CHRPAX
FWRDRT B    @INPUT3

*
* Enter key pressed
*
ISENTR
*
       INC  @PARINX
* Break a paragraph in two.
* Create space in paragraph list.
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYINS
       CI   R0,>FFFF
       JEQ  RTERR
* Save addresses
       MOV  R0,@LINLST
       MOV  R1,R2
* Allocate space for wraplist
       LI   R0,1
       BLWP @ARYALC
       CI   R0,>FFFF
       JEQ  RTERR
* Save address
       MOV  R0,R3
* Calculate length of new paragraph.
       DECT R1
       MOV  *R1,R1
       MOV  *R1,R4
       S    @CHRPAX,R4
* Change length of old paragraph.
       MOV  @CHRPAX,*R1
* Allocate space for new paragraph
       MOV  R4,R0
       C    *R0+,*R0+
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  RTERR
       MOV  R0,R5
* Put paragraph in list
       MOV  R0,*R2
* Set new paragraph length and wrap
* list address
       MOV  R4,*R5+
       MOV  R3,*R5+
* Copy part of old paragraph.
* TODO: If you remove the JEQ command
* the system will freeze for TST14.
* Can't this logic be inside of BUFCPY?
       MOV  R4,R2
       JEQ  ENTR2
       MOV  R1,R0
       C    *R0+,*R0+
       A    @CHRPAX,R0
       MOV  R5,R1
       BLWP @BUFCPY
* Adjust CHRPAX
* PARINX was incremented previously.
ENTR2  CLR  @CHRPAX
* Set document-status bit
       SOC  @STSENT,*R13
* We processed a key, so move KEYRD
* to the next position before leaving
* the INPUT routine.
       BL   @INCKRD
       RTWP

* Somehow let the user know that there
* is no remaining buffer space.
RTERR  RTWP

* User typed some text.
* Put it in the buffer.
* R10 hold address of next input key
ADDTXT
* Set input mode if currently unset
       C    @INPTMD,@INPTNN
	   JNE  ADDT1
	   MOV  @INPTXT,@INPTMD
* If the input mode is not text,
* leave the INPUT routine.
ADDT1  C    @INPTMD,@INPTXT
	   JEQ  ADDT2
	   RTWP
* Set status bit
ADDT2  SOC  @STSTYP,*R13
* Get paragraph address
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
* Is mode insert or overwrite?
       MOV  @INSTMD,R2
       JEQ  INSERT
* R1 already contains address in
* paragraph list.
* If Overwrite position is at the end of
* the paragraph, then act as if this
* were insert mode.
       MOV  *R1,R3
       C    *R3,@CHRPAX
       JEQ  INSERT
* Overwrite text
* R3 contains address of paragraph.
* Set it to the address to overwrite
* text at.
       C    *R3+,*R3+
       A    @CHRPAX,R3
       JMP  RPLTXT
* Check if there is space to insert a
* new character.
* Let R1 be the address in paragraph
* list of current paragraph.
* Let R3 be the address of the
* paragraph.
* Let R5 be the amount of new space
* required.
* Let R6 be the address in the
* paragraph list.
INSERT MOV  R1,R6
       MOV  *R6,R3
       MOV  R3,R4
       DECT R4
       MOV  *R4,R4
       SZC  @BLKUSE,R4
       DECT R4
       MOV  *R3,R5
       AI   R5,5
       C    R5,R4
       JLE  ADDTX1
* Allocate more space
       AI   R5,15
       MOV  R5,R0
       BLWP @BUFALC
       MOV  R0,R1
       MOV  R3,R0
       MOV  R5,R2
       AI   R2,-16
       BLWP @BUFCPY
       MOV  R1,R3
       BLWP @BUFREE
       MOV  R3,*R6
* Insert character.
* Let R4 contain address following
* the paragraph
* Increase paragraph length by one.
* Change R3 to insertion address.
ADDTX1
       MOV  *R3,R4
       INC  *R3
       C    *R3+,*R3+
       A    R3,R4
       A    @CHRPAX,R3
* Copy
       MOV  R4,R5
       DEC  R5
ADDCPY MOVB *R5,*R4
       DEC  R4
       DEC  R5
       C    R5,R3
       JHE  ADDCPY
* put keystroke in new space
RPLTXT MOVB *R10,*R3
* Increase character indexes.
       INC  @CHRPAX
*
       B    @INPUT3

       END