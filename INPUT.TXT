       DEF  INPUT
*
       REF  LINLST,FMTLST,MGNLST
       REF  ARYALC,ARYADD,ARYINS,ARYDEL
       REF  ARYADR
       REF  BUFALC,BUFREE,BUFCPY
       REF  WRAP

* variables just for INPUT
       REF  INPTWS
       REF  KEYSTB,KEYSTE,KEYSTX
       REF  OLDSTB,OLDSTE,OLDSTX
       REF  PARINX,LININX,CHRPAX,CHRLIX
       REF  WINOFF
       REF  INSTMD

* constants
       REF  BLKUSE,USRISR,SIX
       REF  INSKEY,ENDINP
       REF  BCKKEY,FWDKEY,UPPKEY,DWNKEY
       REF  CHRMIN,CHRMAX

INPUT  DATA INPTWS,INPUT+4
       BL   @RSVKS
* Loop that waits for user key input.
INPUT0 LIMI 2
       LIMI 0
       C    @KEYSTB,@KEYSTE
       JEQ  INPUT0
* Deallocate the old key buffer and
* allocate a ne key buffer.
       MOV  @KEYSTB,@OLDSTB
       MOV  @KEYSTE,@OLDSTE
       MOV  @KEYSTX,@OLDSTX
       BL   @RSVKS
* Record space to deallocate later.
       MOV  @OLDSTB,R12
* Process the new keystrokes
INPUT1 MOV  @OLDSTB,R10
* Handle visible character key strokes
       CB   *R10,@CHRMIN
       JL   INPUT2
       CB   *R10,@CHRMAX
       JH   INPUT2
       B    @ADDTXT
*
INPUT2 CB   *R10,@INSKEY
       JEQ  INSSWP
       CB   *R10,@BCKKEY
       JEQ  BACKSP
       CB   *R10,@FWDKEY
       JEQ  FWRDSP
* Check if this was the end of a
* unit test.
       CB   *R10,@ENDINP
       JEQ  INPTRT
* If we got here, this keystroke is 
* unrecognized. Skip it.
INPUT3
*
* Are there more keystrokes to process?
*
       LIMI 2
       LIMI 0
       INC  @OLDSTB
       C    @OLDSTB,@OLDSTE
       JL   INPUT1
* No, there are not
* Wrap paragraph
       MOV  @PARINX,R0
       BLWP @WRAP
       CI   R0,>FFFF
       JEQ  INPTRT
*
* find new LININX and CHRLIX values
*
       MOV  @CHRPAX,R2
       CLR  @LININX
* Set R1 to address of wrap list's
* first item and
* Set R3 to wrap list length
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
       MOV  *R1,R1
       INCT R1
       MOV  *R1,R1
       MOV  *R1,R3
       C    *R1+,*R1+
*
       CLR  R0
LNCLC1 C    @LININX,R3
       JHE  LNCLC2
       C    *R1,R2
       JH   LNCLC2
       MOV  *R1,R0
       INCT R1
       INC  @LININX
       JMP  LNCLC1
LNCLC2 S    R0,R2
       MOV  R2,@CHRLIX
*
* Set new window offset
*
       LI   R1,20
       MOV  @CHRLIX,R2
OFFST0 C    R2,@WINOFF
       JHE  OFFST1
       S    R1,@WINOFF
       JMP  OFFST0
OFFST1 MOV  @CHRLIX,R2
       S    @WINOFF,R2
       CI   R2,40
       JL   OFFST2
       A    R1,@WINOFF
       JMP  OFFST1
OFFST2
* deallocate old key stream
       MOV  R12,R0
       BLWP @BUFREE
       JMP  INPUT0

INPTRT RTWP

* Toggle insert/overwrite mode.
INSSWP INV  @INSTMD
       JMP  INPUT3

*
* Backspace by one position
*
BACKSP DEC  @CHRPAX
       JLT  BACKS1
       JMP  BACKRT
* Backspace to the end of previous
* paragraph.
BACKS1 DEC  @PARINX
       JLT  BACKS2
* Find the length of the paragraph and
* use that as the new character-within-
* paragraph-index.
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
       MOV  *R1,R1
       MOV  *R1,@CHRPAX
       JMP  BACKRT
* The cursor must already be at the
* beginning of the document.
BACKS2 CLR  @CHRPAX
       CLR  @PARINX
BACKRT B    @INPUT3

*
* Fordward space by one position
*
FWRDSP INC  @CHRPAX
* See if we moved beyong paragraph end.
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
       MOV  *R1,R1
       C    *R1,@CHRPAX
*       JH   FWRDS1
       JMP  FWRDRT
* Move to next paragraph.
FWRDS1 INC  @PARINX
       C    @PARINX,*R0
       JEQ  FWRDS2
       CLR  @CHRPAX
       JMP  FWRDRT
* Apparently we reached end of document.
FWRDS2 DEC  @PARINX
       DEC  @CHRPAX
FWRDRT B    @INPUT3

* Reserve new key stream
RSVKS
       LI   R0,32
       BLWP @BUFALC
       CI   R0,>FFFF
       JEQ  RTERR
       MOV  R0,@KEYSTB
       MOV  R0,@KEYSTE
       AI   R0,32
       MOV  R0,@KEYSTX
       RT

* Somehow let the user know that there
* is no remaining buffer space.
RTERR  RTWP

* User typed some text.
* Put it in the buffer.
* R10 hold address of next input key
ADDTXT
* Get paragraph address
       MOV  @LINLST,R0
       MOV  @PARINX,R1
       BLWP @ARYADR
* Is mode insert or overwrite?
       MOV  @INSTMD,R2
       JEQ  INSERT
* R1 already contains address in
* paragraph list.
* If Overwrite position is at the end of
* the paragraph, then act as if this
* were insert mode.
       MOV  *R1,R3
       C    *R3,@CHRPAX
       JEQ  INSERT
* Overwrite text
* R3 contains address of paragraph.
* Set it to the address to overwrite
* text at.
       C    *R3+,*R3+
       A    @CHRPAX,R3
       JMP  RPLTXT
* Check if there is space to insert a
* new character.
* Let R1 be the address in paragraph
* list of current paragraph.
* Let R3 be the address of the
* paragraph.
* Let R5 be the amount of new space
* required.
* Let R6 be the address in the
* paragraph list.
INSERT MOV  R1,R6
       MOV  *R6,R3
       MOV  R3,R4
       DECT R4
       MOV  *R4,R4
       SZC  @BLKUSE,R4
       DECT R4
       MOV  *R3,R5
       AI   R5,5
       C    R5,R4
       JLE  ADDTX1
* Allocate more space
       AI   R5,15
       MOV  R5,R0
       BLWP @BUFALC
       MOV  R0,R1
       MOV  R3,R0
       MOV  R5,R2
       AI   R2,-16
       BLWP @BUFCPY
       MOV  R1,R3
       BLWP @BUFREE
       MOV  R3,*R6
* Insert character.
* Let R4 contain address following
* the paragraph
* Increase paragraph length by one.
* Change R3 to insertion address.
ADDTX1
       MOV  *R3,R4
       INC  *R3
       C    *R3+,*R3+
       A    R3,R4
       A    @CHRPAX,R3
* Copy
       MOV  R4,R5
       DEC  R5
ADDCPY MOVB *R5,*R4
       DEC  R4
       DEC  R5
       LIMI 2
       LIMI 0
       C    R5,R3
       JHE  ADDCPY
* put keystroke in new space
RPLTXT MOVB *R10,*R3
* Increase character indexes.
       INC  @CHRPAX
*
       B    @INPUT3

       END